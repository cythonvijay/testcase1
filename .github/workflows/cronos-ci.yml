name: CRONOS Code Guard

on:
  push:
    branches:
      - main
      - master  # Support both main and master
  pull_request:
    branches:
      - main
      - master

jobs:
  cronos_check:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4  # FIXED: Updated to v4
        with:
          fetch-depth: 0  # FIXED: Fetch full history for reliable diffs
      
      - name: Collect changed files
        id: changes
        run: |
          # FIXED: Handle first commit case
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            git diff --name-only HEAD~1 HEAD > changed_files.txt
          else
            # First commit - list all files
            git ls-files > changed_files.txt
          fi
          
          echo "Changed files:"
          cat changed_files.txt
          
          # Count changed files
          FILE_COUNT=$(wc -l < changed_files.txt)
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
      
      - name: Extract changed code
        id: code
        run: |
          # FIXED: Proper HEAD~1 syntax and error handling
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            # Not first commit - get diff
            CHANGED_CODE=$(git diff HEAD~1 HEAD)
          else
            # First commit - show all new code
            CHANGED_CODE=$(git show HEAD)
          fi
          
          # Save to file
          echo "$CHANGED_CODE" > changed_code.txt
          
          # Show preview
          echo "Code changes preview (first 1000 chars):"
          head -c 1000 changed_code.txt
          echo ""
          echo "..."
          
          # Get character count
          CHAR_COUNT=$(wc -c < changed_code.txt)
          echo "Total characters: $CHAR_COUNT"
      
      - name: Prepare JSON payload
        id: payload
        run: |
          # FIXED: Proper JSON escaping for multiline content
          
          # Read and escape the changed code
          CHANGED_CODE=$(cat changed_code.txt)
          
          # Create payload using Python for reliable JSON encoding
          python3 << 'PYTHON_EOF' > payload.json
import json
import sys

# Read the diff
with open('changed_code.txt', 'r', encoding='utf-8', errors='ignore') as f:
    changed_code = f.read()

# Limit size to prevent API timeouts (max 50KB)
if len(changed_code) > 50000:
    changed_code = changed_code[:50000] + "\n\n[...truncated...]"

# Create payload
payload = {
    "old_code": "",
    "new_code": changed_code,
    "mode": "STRICT"
}

# Write JSON
json.dump(payload, sys.stdout, indent=2)
PYTHON_EOF
          
          echo "Payload created successfully"
          echo "Payload size: $(wc -c < payload.json) bytes"
      
      - name: Send code to CRONOS API
        id: cronos
        continue-on-error: true  # Don't fail workflow if API is down
        run: |
          echo "Sending request to CRONOS API..."
          
          # Send to CRONOS with proper error handling
          HTTP_CODE=$(curl -s -w "\n%{http_code}" -o response.txt \
            -X POST https://final-a8su.onrender.com/analyze_ci \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -d @payload.json \
            --max-time 120 \
            --retry 2 \
            --retry-delay 5)
          
          # Extract status code (last line)
          HTTP_STATUS=$(echo "$HTTP_CODE" | tail -n1)
          
          echo "HTTP Status: $HTTP_STATUS"
          
          # Save response
          head -n -1 response.txt > result.json || cp response.txt result.json
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ API request successful"
            cat result.json | jq '.' || cat result.json
          else
            echo "‚ùå API Error (HTTP $HTTP_STATUS)"
            cat result.json
            
            # Create fallback response for downstream steps
            cat > result.json << 'EOF'
{
  "risk": 0,
  "status": "PASS",
  "mode": "FALLBACK",
  "findings_count": 0,
  "summary": ["API unavailable - skipping analysis"],
  "pass": true,
  "warn": false,
  "fail": false,
  "api_error": true
}
EOF
          fi
      
      - name: Show CRONOS response
        run: |
          echo "=========================================="
          echo "CRONOS Analysis Results"
          echo "=========================================="
          
          if [ -f result.json ]; then
            cat result.json | jq '.' 2>/dev/null || cat result.json
          else
            echo "‚ö†Ô∏è  No result file found"
          fi
          
          echo "=========================================="
      
      - name: Evaluate risk score and decide deployment
        id: decision
        run: |
          # Check if result file exists
          if [ ! -f result.json ]; then
            echo "‚ö†Ô∏è  No analysis result - allowing deployment"
            exit 0
          fi
          
          # Extract values with fallbacks
          RISK=$(jq -r '.risk // 0' result.json)
          STATUS=$(jq -r '.status // "UNKNOWN"' result.json)
          FINDINGS=$(jq -r '.findings_count // 0' result.json)
          API_ERROR=$(jq -r '.api_error // false' result.json)
          
          echo "Risk Score: $RISK/100"
          echo "Status: $STATUS"
          echo "Findings: $FINDINGS"
          echo ""
          
          # Show summary if available
          if [ "$FINDINGS" -gt 0 ]; then
            echo "Summary of issues:"
            jq -r '.summary[]?' result.json 2>/dev/null | sed 's/^/  ‚Ä¢ /' || echo "  (details unavailable)"
            echo ""
          fi
          
          # Skip enforcement if API had errors
          if [ "$API_ERROR" = "true" ]; then
            echo "‚ö†Ô∏è  CRONOS API unavailable - skipping enforcement"
            echo "Deployment allowed (API error)"
            exit 0
          fi
          
          # Decision logic
          if [ "$RISK" -ge 60 ]; then
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚ùå DEPLOYMENT BLOCKED BY CRONOS"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Risk score ($RISK) exceeds acceptable threshold (60)"
            echo "Status: $STATUS"
            echo ""
            echo "üö® Action required: Review and fix reported issues"
            echo ""
            echo "To bypass (emergency only):"
            echo "  git commit --amend -m \"your message [skip ci]\""
            echo "  git push --force"
            exit 1
            
          elif [ "$RISK" -ge 21 ]; then
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚ö†Ô∏è  WARNING: Medium Risk Detected"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Risk score: $RISK/100"
            echo "Status: $STATUS"
            echo ""
            echo "Recommendation: Manual review recommended"
            echo "‚úì Proceeding with deployment..."
            
          else
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "‚úÖ SAFE TO DEPLOY"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Risk score: $RISK/100"
            echo "Status: $STATUS"
            echo ""
            echo "All checks passed!"
          fi
      
      - name: Upload CRONOS report
        uses: actions/upload-artifact@v4  # FIXED: Updated to v4
        if: always()
        with:
          name: cronos-analysis-report-${{ github.run_id }}
          path: |
            result.json
            changed_files.txt
            changed_code.txt
          retention-days: 30
          if-no-files-found: warn
      
      - name: Comment on PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7  # FIXED: Updated to v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            
            // Check if result file exists
            if (!fs.existsSync('result.json')) {
              console.log('No result.json found, skipping PR comment');
              return;
            }
            
            const result = JSON.parse(fs.readFileSync('result.json', 'utf8'));
            
            // Handle API errors
            if (result.api_error) {
              const body = `## ‚ö†Ô∏è CRONOS Analysis Unavailable\n\n` +
                `The CRONOS API was unavailable during this check.\n\n` +
                `**Status:** API Error\n` +
                `**Action:** Deployment allowed (check passed by default)\n\n` +
                `---\n*CRONOS v5.0.0*`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
              return;
            }
            
            // Normal analysis result
            const riskEmoji = result.risk >= 60 ? 'üî¥' : result.risk >= 21 ? 'üü°' : 'üü¢';
            const statusEmoji = result.status === 'FAIL' ? '‚ùå' : result.status === 'WARN' ? '‚ö†Ô∏è' : '‚úÖ';
            
            let body = `## ${riskEmoji} CRONOS Code Analysis Report\n\n`;
            body += `**Status:** ${statusEmoji} ${result.status}\n`;
            body += `**Risk Score:** ${result.risk}/100\n`;
            body += `**Mode:** ${result.mode}\n`;
            body += `**Findings:** ${result.findings_count}\n\n`;
            
            if (result.findings_count > 0 && result.summary) {
              body += `### üîç Issues Detected:\n`;
              result.summary.forEach(issue => {
                body += `- ${issue}\n`;
              });
              body += `\n`;
            } else {
              body += `‚úÖ No issues detected. Code looks good!\n\n`;
            }
            
            // Add decision
            if (result.risk >= 60) {
              body += `### ‚ùå Deployment Blocked\n`;
              body += `This PR cannot be merged due to high-risk changes.\n`;
              body += `Please review and address the issues above.\n\n`;
            } else if (result.risk >= 21) {
              body += `### ‚ö†Ô∏è Review Recommended\n`;
              body += `Manual review recommended before merging.\n\n`;
            } else {
              body += `### ‚úÖ Approved\n`;
              body += `Safe to merge!\n\n`;
            }
            
            body += `---\n`;
            body += `*Analyzed by CRONOS v5.0.0 at ${result.timestamp || 'unknown'}*`;
            
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
